pragma solidity ^0.8.0;

import "../../Multisig/ZippieMultisig.sol";
import "../../Card/ZippieCard.sol";
import "../../Utils/ZippieUtils.sol";
import "../../Account/ZippieAccount.sol";

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";

/**
  * @title Zippie Multisig Wallet for ERC721 (with 2FA smart card)
  * @notice Transfer ERC721 tokens (NFT) using multiple signatures
  * @dev Zippie smart cards can be used for 2FA
 */
contract ZippieWalletERC721 is ZippieAccount, ZippieMultisig, ZippieCard {

    constructor(address zippieCardNonces) 
        // ZippieAccountERC721.sol 
        ZippieAccount(hex'608060405234801561001057600080fd5b50600080546001600160a01b0319163317905560ff806100316000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063daea85c514602d575b600080fd5b605060048036036020811015604157600080fd5b50356001600160a01b03166052565b005b6000546001600160a01b03163314606857600080fd5b60408051600160e01b63a22cb4650281523360048201526001602482015290516001600160a01b0383169163a22cb46591604480830192600092919082900301818387803b15801560b857600080fd5b505af115801560cb573d6000803e3d6000fd5b503292505050fffea165627a7a72305820138a39f8dcc74909958a7c9a3debcc975c1b1527953c47473594aa49882499790029')
        ZippieCard(zippieCardNonces) 
        public {}

    /** @notice Redeems a blank check after verifying required signers/cards 
      * (recipient is specified when check is claimed) 
      * @dev Transfer ERC721 tokens when verified that 
      * enough signers has signed keccak256(amount, verification key)
      * card signatures are not required if amount doesn't exceeded the current limit
      * @param addresses required addresses
      * [0] ERC721 token to transfer
      * [1] recipient of the ERC721 token
      * [2] verification key (nonce)
      * @param signers all possible signers and cards
      * [0..i] signer adresses
      * [i+1..j] card addresses
      * @param m the amount of signatures required for this multisig account
      * [0] possible number of signers
      * [1] required number of signers
      * [2] possible number of cards
      * [3] reqiuired number of cards
      * @param v v values of all signatures
      * [0] verification key signature
      * [1..i] signer signatures of check hash
      * [i+1..j] card signatures of random card nonces
      * @param r r values of all signatures (structured as v)
      * @param s s values of all signatures (structured as v)
      * @param tokenId non-fungible token (NFT) to transfer
      * @param cardNonces random nonce values generated by cards at every read
      * @return true if transfer successful 
      */
    function redeemBlankCheck(
        address[] memory addresses, 
        address[] memory signers, 
        uint8[] memory m, 
        uint8[] memory v, 
        bytes32[] memory r, 
        bytes32[] memory s, 
        uint256 tokenId, 
        bytes32[] memory cardNonces
    ) 
        public 
        returns (bool)
    {
        require(
            addresses.length == 3, 
            "Incorrect number of addresses"
        ); 

        // get account address
        address accountAddress = getAccountAddress(
            keccak256(abi.encodePacked(signers, m))
        );

        // sanity check of signature parameters 
        checkSignatureParameters(
            m, 
            signers.length, 
            v.length, 
            r.length, 
            s.length, 
            cardNonces.length
        );

        // verify that account nonce is valid (for replay protection)
        // (verification key signing recipient address)
        verifyMultisigNonce(
            accountAddress, 
            addresses[2], 
            addresses[1],
            ZippieUtils.toEthSignedMessageHash(
                keccak256(abi.encodePacked(addresses[1]))
            ), 
            v[0], 
            r[0], 
            s[0]
        );

        // get the check hash (token, tokenIs, nonce) 
        // and verify that required number of signers signed it 
        // (recipient is specified when check is claimed)
        // prepend with function name "redeemBlankCheck"
        // so a hash for another function with same parameter 
        // layout don't get the same hash
        verifyMultisigSignerSignatures(
            ZippieUtils.toEthSignedMessageHash(
                keccak256(abi.encodePacked("redeemBlankCheck", addresses[0], tokenId, addresses[2]))
            ), 
            [0, m[0]], 
            signers, 
            [1, m[1]], 
            v, 
            r, 
            s
        );

        // verify that requied number of 
        // card signatures has been provided (but only if account has a card)
        if (m[3] > 0) {
            // verify that card nonces are valid 
            // and has not been used already
            verifyCardSignatures(
                cardNonces, 
                [m[0], m[2]], 
                signers, 
                [1+m[1], m[3]], 
                v, 
                r, 
                s
            );
        }

        // sender and recipient are same (i.e. "cancel")
        // but don't need to send tokens to back to same account
        // just mark verification key (nonce) as used
        if(accountAddress == addresses[1]) {
            return true;
        }

        // check if account needs to be "created" (ERC721 setApprovalForAll)
        if(IERC721(addresses[0]).isApprovedForAll(accountAddress, address(this)) == false) {
            require(
                approveToken(addresses[0], keccak256(abi.encodePacked(signers, m))) == accountAddress, 
                "Token approval failed"
            );
        }

        // transfer NFT from multisig account to recipient address
        IERC721(addresses[0]).transferFrom(accountAddress, addresses[1], tokenId);
        return true;
    }

    /** 
      * @dev sanity check of signature related parameters
      */
    function checkSignatureParameters(
        uint8[] memory m, 
        uint256 nrOfSigners, 
        uint256 nrOfVs, 
        uint256 nrOfRs, 
        uint256 nrOfSs, 
        uint256 nrOfCardNonces
    ) 
        private 
        pure
        returns (bool)
    {
        require(
            m.length == 4, 
            "Invalid m[]"
        ); 
        require(
            m[1] <= m[0],
            "Required number of signers cannot be higher than number of possible signers"
        );
        require(
            m[3] <= m[2], 
            "Required number of cards cannot be higher than number of possible cards"
        );
        require(
            m[0] > 0, 
            "Required number of signers cannot be 0"
        );           
        require(
            m[1] > 0, 
            "Possible number of signers cannot be 0"
        );  
        require(
            m[0] != 0xFF, 
            "Required number of signers cannot be MAX UINT8"
        ); 
        require(
            m[1] != 0xFF, 
            "Possible number of signers cannot be MAX UINT8"
        ); 
        require(
            m[2] != 0xFF, 
            "Required number of cards cannot be MAX UINT8"
        ); 
        require(
            m[3] != 0xFF, 
            "Possible number of cards cannot be MAX UINT8"
        ); 
        require(
            nrOfSigners == m[0] + m[2], 
            "Incorrect number of signers"
        ); 
        require(
            nrOfVs == 1 + m[1] + m[3], 
            "Incorrect number of signatures (v)"
        ); 
        require(
            nrOfRs == 1 + m[1] + m[3], 
            "Incorrect number of signatures (r)"
        ); 
        require(
            nrOfSs == 1 + m[1] + m[3], 
            "Incorrect number of signatures (s)"
        ); 
        require(
            nrOfCardNonces == m[3], 
            "Incorrect number of card nonces"
        ); 
        return true;
    }
}